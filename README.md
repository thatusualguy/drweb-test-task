# Dr.Web Test Task

## Стек
- Python 3.13+
- FastAPI (ASGI), запуск через Uvicorn
- SQLite (локальный файл app.sqlite) через SQLAlchemy 2.0 и aiosqlite
- Очередь и исполнение: asyncio + Semaphore (ограничение задачи), фоновые задачи FastAPI
- Схемы валидации: Pydantic
- Управление зависимостями: uv + pyproject.toml

## Архитектура решения
- API-слой (src/drweb_app/main.py):
    - POST /task - создает запись о задаче, ставит статус In Queue и возвращает id.
    - GET /task/{id} - отдает статус и временные метки задачи.
- Бизнес-логика (src/drweb_app/tasks/task.py):
    - Задача-заглушка (time.sleep/asyncio.sleep со случайной задержкой).
- Планировщик (src/drweb_app/tasks/task_runner.py):
    - Запускает задачи из очереди, ограничивает одновременный запуск до 2 задач через asyncio.Semaphore.
    - Фиксирует start_time и exec_time.
- Слой данных (src/drweb_app/db):
    - database.py - создание engine/Session.
    - models.py - ORM-модель Task.
- Схемы (src/drweb_app/schema.py):
    - Pydantic-модели для входных/выходных DTO.
- Конфигурация (src/drweb_app/config.py):
    - Параметры приложения (например, кол-во параллельных задач).

Поток обработки:
1) Клиент вызывает POST /task → создается запись в БД, задача добавляется в очередь.
2) Раннер подхватывает задачи по мере освобождения семафора, ставит статус Run, фиксирует start_time и выполняет заглушку.
3) По завершении - статус Completed, рассчитывается exec_time и сохраняется в БД.
4) Клиент опрашивает GET /task/{id} и получает текущее состояние и тайминги.

## Задача
Необходимо реализовать прототип веб-сервиса по организации очереди задач.

Допускается труднореализуемые или непонятные моменты описать алгоритмически.

### Требования к прототипу:
- Реализовать API-endpoint, при обращении к которому создается задача, которая добавляется в очередь, и пользователю возвращается номер задачи.
- Второй API-endpoint возвращает статус задачи в формате json {'status': '...', 'create_time": '...', 'start_time': '...', 'time_to_execute': '...'}.

Статусы:
- In Queue -- задача ждёт своей очереди на выполнение;
- Run -- произошел запуск задачи;
- Completed -- задача выполнена.


Выполнение задачи представляет собой заглушку в виде python-кода:
```
time.sleep(random.randint(0,10))
```

### Обратите внимание:
- Можно создавать множество задач, но выполняться одновременно должно не более 2 (двух);
- Результаты записать в локальную БД с полями: id (первичный ключ, номер поставленной задачи), create_time (время создания задачи), start_time (время старта задачи), exec_time (время выполнения задачи);
- Нельзя использовать celery/dramariq/taskiq и другие готовые фреймворки для работы с очередями задач;
- При написании стоит использовать python>=3.9, БД на свое усмотрение, любой веб-фреймворк (желательно асинхронный).